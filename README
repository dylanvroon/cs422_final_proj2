Compile: make / make all
Run tests: make clean && make TEST=1
Run in qemu: make qemu / make qemu-nox
Debug with gdb: make qemu-gdb / make qemu-nox-gdb
                (in another terminal) gdb

To use your solutions from lab 1: git merge lab1
To use sample lab 1 solutions: copy files in samples/ to appropriate directories

List here the following info:
1. Dylan Vroon and Evan Schott
2. We coded this assignment together

Description of final project:
For the final project, we decided to implement prompt 10: dynamically allocated memory. We split this project into multiple parts. First we implemented the ability for the user to allocate pages with the syscall brk. Initially, it was only possible to allocate one page at a time, and successive allocations we're not ensured to be sequential. Brk(vaddr, n) can be used to allocate consecutive pages of memory (both physically and virtually). Like the standard brk(), brk takes as input an address, but it also takes in a length n to offer more customizability. With n=0, a super page is allocated of size 4MB (1024 pages in a row). Other values of n correspond to allocating n single pages in a row. We also implemented the syscall free as a counterpart to brk. Free takes in an address and length just like brk, and uses the same criteria to judge whether to free a superpage or free a set of consecutive pages. We implemented these syscalls by making signifigant changes to the pmm and vmm layers. In the pmm layer we implemented the buddy memory allocation algorithm to provide efficient solution to fragmentation problem. In the vmm layer we added support for allocating and removing both super pages and consecutive single pages across virtual memory. 